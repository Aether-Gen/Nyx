<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>NYX — GPN Viewer (CSV)</title>
<style>
  :root{
    --bg0:#071a2a; --panel:#0b2236cc; --line:#0e3553;
    --text:#e8f3ff; --muted:#a9bfd3;
    --btn:#0f3a59; --btn2:#124a72;
    --stroke: rgba(90,208,255,0.25);
    --strokeHi: rgba(90,208,255,0.95);
    --fillHi: rgba(90,208,255,0.10);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    background: radial-gradient(1200px 900px at 30% 0%, #113a5d 0%, var(--bg0) 55%, #061322 100%);
    color:var(--text);
  }
  .wrap{display:grid;grid-template-columns:320px 1fr;min-height:100vh}
  .panel{
    padding:14px 14px 10px;
    background:linear-gradient(180deg,var(--panel),#071a2aee);
    border-right:1px solid var(--line)
  }
  h1{font-size:15px;margin:4px 0 10px;letter-spacing:.06em}
  .hint{font-size:12px;color:var(--muted);line-height:1.35;margin-bottom:12px}
  .card{border:1px solid var(--line);border-radius:10px;padding:10px;margin:10px 0;background:#061827aa}
  .card h2{font-size:12px;margin:0 0 8px;color:#cfe6ff;letter-spacing:.08em}
  label{display:block;font-size:12px;color:var(--muted);margin:8px 0 4px}
  input[type="text"],input[type="number"]{
    width:100%;padding:8px 10px;border-radius:8px;border:1px solid var(--line);
    background:#041220;color:var(--text);outline:none
  }
  .row2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .btn{
    width:100%;padding:9px 10px;border-radius:10px;
    border:1px solid #1a557b;background:linear-gradient(180deg,var(--btn2),var(--btn));
    color:var(--text);cursor:pointer;font-weight:600;letter-spacing:.04em
  }
  .btn:active{transform:translateY(1px)}
  .small{font-size:11px;color:var(--muted);margin-top:6px}
  .status{font-size:12px;margin-top:8px;color:#bfe3ff}
  .status b{color:#8dffb5}
  .canvasWrap{position:relative;overflow:auto}
  canvas{display:block}
  .hud{
    position:fixed;left:340px;right:14px;bottom:14px;
    background:#041220cc;border:1px solid var(--line);border-radius:12px;
    padding:8px 10px;font-size:12px;color:#d7ecff;
    display:flex;gap:12px;align-items:center;backdrop-filter: blur(6px);
  }
  .pill{padding:4px 8px;border-radius:999px;border:1px solid var(--line);background:#061827aa;color:#cfe6ff}
  .pill b{color:#ffffff}
</style>
</head>
<body>
<div class="wrap">
  <aside class="panel">
    <h1>NYX — GPN Viewer (CSV)</h1>
    <div class="hint">
      Desenha <b>1 hex por par de colunas</b> (2 colunas no Sheets = 1 hex).
      Hex <b>em pé</b> (pointy-top). Regra: <b>colunas pares (2,4,6…) ficam mais baixas</b>.
      Sem coloração aleatória.
    </div>

    <div class="card">
      <h2>FONTE (CSV)</h2>
      <label>Arquivo (mesma pasta do HTML no GitHub Pages)</label>
      <input id="csvUrl" type="text" value="hex_grid.csv"/>
      <button id="btnLoad" class="btn">Recarregar CSV</button>
      <div class="small">Auto-carrega ao abrir a página.</div>
      <div id="status" class="status">Status: aguardando…</div>
    </div>

    <div class="card">
      <h2>CALIBRAÇÃO</h2>
      <div class="row2">
        <div>
          <label>Tamanho do hex (s)</label>
          <input id="hexSize" type="number" step="0.1" value="11"/>
        </div>
        <div>
          <label>Offset X</label>
          <input id="offX" type="number" step="1" value="30"/>
        </div>
      </div>
      <div class="row2">
        <div>
          <label>Offset Y</label>
          <input id="offY" type="number" step="1" value="30"/>
        </div>
        <div>
          <label>Gap extra (Y)</label>
          <input id="gapY" type="number" step="0.1" value="0"/>
        </div>
      </div>
      <button id="btnApply" class="btn">Aplicar</button>
      <div class="small">
        Geometria (pointy-top): <b>stepX = √3·s</b> (aresta com aresta), <b>stepY = 1,5·s + gapY</b>.
        Offset por coluna: <b>shiftCol = stepY/2</b> (coluna par mais baixa).
      </div>
    </div>

    <div class="card">
      <h2>BUSCA</h2>
      <label>HexFuncID (ex: 0001)</label>
      <input id="qFunc" type="text" placeholder="0001"/>
      <button id="btnFindFunc" class="btn">Destacar</button>
      <button id="btnClear" class="btn" style="margin-top:8px">Limpar seleção</button>
      <div class="small">Aceita “#” e espaços. Ex.: “#0001”.</div>
    </div>
  </aside>

  <main class="canvasWrap">
    <canvas id="cv"></canvas>
  </main>
</div>

<div class="hud">
  <div class="pill">Hover: <b id="hudHover">—</b></div>
  <div class="pill">Seleção: <b id="hudPick">—</b></div>
</div>

<script>
/**
 * ✅ REGRA CONFIRMADA (seu texto):
 *  _1_3_5
 *  2_4_6
 *  _7_9_11
 *  8_10_12
 *
 * Interpretação no renderer:
 *  - q começa em 0 na primeira coluna desenhada.
 *  - q par (0,2,4,...) = coluna "ímpar" visual => MAIS ALTA
 *  - q ímpar (1,3,5,...) = coluna "par" visual => MAIS BAIXA (meio-hex)
 */

let TUNE = { hexSize: 11, offX: 30, offY: 30, gapY: 0 };

const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');

const elStatus = document.getElementById('status');
const elHover = document.getElementById('hudHover');
const elPick  = document.getElementById('hudPick');
const elCsvUrl = document.getElementById('csvUrl');

document.getElementById('btnLoad').addEventListener('click', () => loadCSVFromURL(elCsvUrl.value.trim()));
document.getElementById('btnApply').addEventListener('click', () => {
  TUNE.hexSize = Number(document.getElementById('hexSize').value) || 11;
  TUNE.offX    = Number(document.getElementById('offX').value) || 0;
  TUNE.offY    = Number(document.getElementById('offY').value) || 0;
  TUNE.gapY    = Number(document.getElementById('gapY').value) || 0;
  render();
});

document.getElementById('btnClear').addEventListener('click', () => {
  PICK = null; PICK_FUNC = null; render();
});
document.getElementById('btnFindFunc').addEventListener('click', () => {
  const raw = (document.getElementById('qFunc').value || '').trim().replace(/[^0-9]/g,'');
  if(!raw) return;
  PICK_FUNC = raw.padStart(4,'0');
  PICK = null;
  render(true);
});

/* =========================
   CSV parser robusto
   ========================= */
function parseCSV(text){
  const rows = [];
  let row = [];
  let i=0, cur='', inQ=false;
  while(i < text.length){
    const ch = text[i];
    if(inQ){
      if(ch === '"'){
        if(text[i+1] === '"'){ cur+='"'; i+=2; continue; }
        inQ=false; i++; continue;
      } else { cur+=ch; i++; continue; }
    } else {
      if(ch === '"'){ inQ=true; i++; continue; }
      if(ch === ','){ row.push(cur); cur=''; i++; continue; }
      if(ch === '\r'){ i++; continue; }
      if(ch === '\n'){ row.push(cur); rows.push(row); row=[]; cur=''; i++; continue; }
      cur+=ch; i++; continue;
    }
  }
  row.push(cur); rows.push(row);
  while(rows.length && rows[rows.length-1].every(c => (c||'').trim()==='')) rows.pop();
  return rows;
}
function normNum(s){
  if(s==null) return null;
  const t = String(s).trim().replace(',', '.');
  if(t==='') return null;
  const v = Number(t);
  return Number.isFinite(v) ? v : null;
}
function fmt(v){
  if(v===null || v===undefined) return '—';
  if(Number.isFinite(v)) return String(v).replace('.', ',');
  return String(v);
}

/* =========================
   Modelo interno
   - 1a linha: meridianos (ignora)
   - 2a linha: valores das colunas (43, 43,5, 44...)
   - a partir da 3a: primeira(s) coluna(s) tem o valor da linha (17, 16,5...)
     e o resto é o grid: cada HEX = 2 COLUNAS
   ========================= */
let MODEL = null;
let PICK = null;
let PICK_FUNC = null;

function buildModel(csv){
  if(csv.length < 3) throw new Error('CSV curto demais.');

  // linha 2: col headers (números)
  const colHeader = csv[1];

  // detecta onde começam os números das colunas
  let startC = 0;
  for(let c=0;c<colHeader.length;c++){
    if(normNum(colHeader[c]) !== null){ startC = c; break; }
  }

  const colVals = [];
  for(let c=startC;c<colHeader.length;c++) colVals.push(normNum(colHeader[c]));

  // IMPORTANTÍSSIMO: NÃO “COMPRIMIR” LINHAS.
  // Mantém rr alinhado com a ordem real do CSV.
  const dataRows = [];
  const rowVals  = [];

  for(let r=2;r<csv.length;r++){
    const row = csv[r] || [];

    // tenta achar rowValue antes do startC
    let rowV = null;
    for(let c=0;c<Math.min(startC,row.length);c++){
      const v = normNum(row[c]);
      if(v !== null){ rowV = v; break; }
    }
    if(rowV===null && startC>0) rowV = normNum(row[startC-1]);

    rowVals.push(rowV);
    dataRows.push(row.slice(startC));
  }

  const maxCsvCols = Math.max(...dataRows.map(r=>r.length), 0);
  const pairCount = Math.floor(maxCsvCols / 2);

  const hexes = [];
  for(let rr=0; rr<dataRows.length; rr++){
    const gridRow = dataRows[rr];
    for(let q=0; q<pairCount; q++){
      const c0 = q*2, c1 = q*2 + 1;
      const v0 = (gridRow[c0] ?? '').trim();
      const v1 = (gridRow[c1] ?? '').trim();
      const raw = (v0 || v1 || '').trim();
      if(!raw) continue;

      const funcID = raw.replace(/[^0-9]/g,'').padStart(4,'0');
      const colValue = colVals[c0] ?? null; // âncora no 1º meio-hex
      const rowValue = rowVals[rr] ?? null;

      hexes.push({ q, rr, funcID, colValue, rowValue });
    }
  }

  return { startC, colVals, rowVals, dataRows, pairCount, hexes };
}

/* =========================
   Geometria correta (hex em pé)
   ========================= */
function steps(){
  const s = TUNE.hexSize;
  const stepX = Math.sqrt(3) * s;      // aresta com aresta horizontal
  const stepY = 1.5 * s + TUNE.gapY;   // “escada” vertical correta
  const shiftCol = stepY / 2;          // meio-hex vertical entre colunas
  return { s, stepX, stepY, shiftCol };
}

// ✅ coluna par (visual) mais baixa => aqui: q ímpar desce
function hexCenter(q, rr){
  const { stepX, stepY, shiftCol } = steps();
  const x = TUNE.offX + q * stepX;
  const y = TUNE.offY + rr * stepY + ((q % 2) ? shiftCol : 0);
  return { x, y };
}

function hexPath(x,y){
  const s = TUNE.hexSize;
  const pts = [];
  // pointy-top: 30,90,150,210,270,330
  for(let k=0;k<6;k++){
    const a = (Math.PI/180) * (60*k - 30);
    pts.push([x + s*Math.cos(a), y + s*Math.sin(a)]);
  }
  return pts;
}
function drawHex(x,y, stroke, fill){
  const pts = hexPath(x,y);
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.closePath();
  if(fill){ ctx.fillStyle = fill; ctx.fill(); }
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1;
  ctx.stroke();
}

/* =========================
   Render / Hit test
   ========================= */
function resizeCanvas(){
  const w = window.innerWidth - 320;
  const h = window.innerHeight;
  canvas.width = Math.max(900, w);
  canvas.height = Math.max(600, h);
}
function clear(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#071a2a';
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

function render(ensureFind=false){
  resizeCanvas();
  clear();

  if(!MODEL){
    elHover.textContent = '—';
    elPick.textContent = '—';
    return;
  }

  let foundIndex = -1;
  if(PICK_FUNC){
    foundIndex = MODEL.hexes.findIndex(h => h.funcID === PICK_FUNC);
    if(foundIndex >= 0 && ensureFind){
      PICK = foundIndex;
      const {x,y} = hexCenter(MODEL.hexes[foundIndex].q, MODEL.hexes[foundIndex].rr);
      const wrap = document.querySelector('.canvasWrap');
      wrap.scrollTo({ left: Math.max(0, x - wrap.clientWidth*0.5), top: Math.max(0, y - wrap.clientHeight*0.5), behavior:'smooth' });
    }
  }

  for(let i=0;i<MODEL.hexes.length;i++){
    const h = MODEL.hexes[i];
    const {x,y} = hexCenter(h.q, h.rr);
    const isPick = (PICK === i);
    const isFunc = (PICK_FUNC && h.funcID === PICK_FUNC);
    drawHex(
      x,y,
      (isPick||isFunc) ? getCSS('--strokeHi') : getCSS('--stroke'),
      (isPick||isFunc) ? getCSS('--fillHi')   : null
    );
  }

  if(PICK !== null && MODEL.hexes[PICK]){
    const h = MODEL.hexes[PICK];
    elPick.textContent = `func=${h.funcID} | q=${h.q} rr=${h.rr} | col=${fmt(h.colValue)} lin=${fmt(h.rowValue)}`;
  } else if(PICK_FUNC && foundIndex>=0){
    const h = MODEL.hexes[foundIndex];
    elPick.textContent = `func=${h.funcID} | q=${h.q} rr=${h.rr} | col=${fmt(h.colValue)} lin=${fmt(h.rowValue)}`;
  } else {
    elPick.textContent = '—';
  }
}

function getCSS(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

// hit-test por centro (suficiente e rápido)
function nearestHexIndex(mx,my){
  if(!MODEL) return -1;
  let best=-1, bestD=Infinity;
  for(let i=0;i<MODEL.hexes.length;i++){
    const h = MODEL.hexes[i];
    const {x,y} = hexCenter(h.q, h.rr);
    const dx = mx-x, dy = my-y;
    const d = dx*dx + dy*dy;
    if(d < bestD){ bestD=d; best=i; }
  }
  const s = TUNE.hexSize;
  return (best>=0 && bestD <= (s*1.05)*(s*1.05)) ? best : -1;
}

/* =========================
   Interação
   ========================= */
let lastHover=-1;

canvas.addEventListener('mousemove', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;
  const idx = nearestHexIndex(mx,my);

  if(idx !== lastHover){
    lastHover = idx;
    if(idx>=0){
      const h = MODEL.hexes[idx];
      elHover.textContent = `func=${h.funcID} | q=${h.q} rr=${h.rr} | col=${fmt(h.colValue)} lin=${fmt(h.rowValue)}`;
    } else {
      elHover.textContent = '—';
    }
    render(); // redesenha só para atualizar highlight
  }
});

canvas.addEventListener('click', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;
  const idx = nearestHexIndex(mx,my);
  if(idx>=0){
    PICK = idx;
    PICK_FUNC = null;
    render();
  }
});

/* =========================
   Load CSV
   ========================= */
async function loadCSVFromURL(url){
  try{
    elStatus.textContent = 'Status: carregando…';
    const res = await fetch(url, { cache:'no-store' });
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const text = await res.text();
    const csv = parseCSV(text);
    MODEL = buildModel(csv);

    elStatus.innerHTML = `Status: <b>OK</b> — pares=${MODEL.pairCount}, linhas=${MODEL.dataRows.length}, hexes=${MODEL.hexes.length}`;
    render();
  } catch (err){
    console.error(err);
    elStatus.textContent = 'Status: erro — ' + (err.message || String(err));
    MODEL = null;
    render();
  }
}

/* Auto-load */
window.addEventListener('load', ()=>{
  document.getElementById('hexSize').value = TUNE.hexSize;
  document.getElementById('offX').value = TUNE.offX;
  document.getElementById('offY').value = TUNE.offY;
  document.getElementById('gapY').value = TUNE.gapY;
  loadCSVFromURL(elCsvUrl.value.trim());
});
window.addEventListener('resize', ()=>render());
</script>
</body>
</html>
